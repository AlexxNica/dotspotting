{literal}
<script type="text/javascript">

function collect_headers(){

	var headers = $("#user_sheets thead tr").map(function(i, row){

		var _headers = [];

		$(row).find("th").each(function(col, th){
			_headers.push($(th).text().toLowerCase());
		});

		return _headers;
	});

	return headers;
}

function sheet_onclick(sheetid){

	var sheet = sheet_getinfo(sheetid);

	if (sheet){		
		location.href = sheet.url;
	}
}

function sheet_onmouseover(sheetid){

	var sheet = sheet_getinfo(sheetid);

	if (! sheet['id']){
		return;
	}	

	var tlen = _dotspotting.sheets_list_mouseout_timers.length;

	for (var i = 0; i < tlen; i++){
		clearTimeout(_dotspotting.sheets_list_mouseout_timers.pop());
	}

	var html = 'This is sheet #<a href="' + sheet['url'] + '">' + htmlspecialchars(sheet['id']) + '</a>';

	if ((sheet.ownerid) && (sheet.ownerid != _dotspotting.user.id)){
		html += ', by ' + htmlspecialchars(sheet.owner);
	}

	else {
		html += ', by you';
	}

	html += '.';

	if (sheet['label']){
		html += ' It is labeled <q>' + htmlspecialchars(sheet['label']) + '</q>.';
	}

	var count_dots = sheet['countdots_public'];

	if (count_dots){

		if (count_dots > 1){
			html += ' It has ' + htmlspecialchars(count_dots) + ' dots.';
		}

		else {
			html += ' It has ' + htmlspecialchars(count_dots) + ' dot.';
		}
	}

	$("#map_info").html(html);
	$("#map_info").show();
}

function sheet_onmouseout(sheetid){

	var html = $("#map_info").html();
	html = html.replace(/^This is/, 'That was');

	$("#map_info").html(html);

	var tid = setTimeout(function(){

		$("#map_info").fadeOut('slow', function(){
			$("#map_info").html('');
		});

	}, 8000);

	_dotspotting.sheets_list_mouseout_timers.push(tid);
}

function sheet_getinfo(sheetid){

    if (_dotspotting.sheets_list_sheets[sheetid]){	
       return _dotspotting.sheets_list_sheets[sheetid];
    }      

    var row = $("#sheetslist_sheet_" + sheetid);
    var sheet = row2sheet(row);

    _dotspotting.sheets_list_sheets[sheetid] = sheet;
    return sheet;
}

function row2sheet(row, headers){

	var sheet = {};

	$(row).find("td").each(function(col, td){

		var classes = $(td).attr("class");
		var key = (headers) ? headers[col].toLowerCase() : null;

		if (classes){

			var match = classes.match(/\bsheetslist_([a-z_]+)\b/);

			if (match){
				key = match[1];
			}
		}

		if (! key){
			return {};
		}

		var value = $(td).text();
		value = value.replace(/^\s+/, '');
		value = value.replace(/\s+$/, '');
		
		if (key == 'extent'){
			var _extent = value.split(' ');
			value = (_extent.length == 4) ? _extent : null;
		}

		else if (key == 'label'){
			value = (value == 'â€”') ? null : value;
		}

		else if (key == 'owner'){

			// I am not convinced this is the right way to do this...

			var ownerid = $(td).attr("ds:owner_id");

			if (ownerid){
				sheet['ownerid'] = Number(ownerid);
			}
		}

		else {}

		sheet[ key ] = value;
	});

	if (sheet['id']){
		sheet['url'] = _dotspotting.abs_root_url + 'u/' + encodeURIComponent(sheet['ownerid']) + '/sheets/' + encodeURIComponent(sheet['id']) + '/';
	}

	return sheet;
}

function collect_sheets(){

	var headers = collect_headers();
	var sheets = [];

	var swlat = null;
	var swlon = null;
	var nelat = null;
	var nelon = null;

	var features = $("#user_sheets tbody tr").map(function(i, row) {

		var sheet = row2sheet(row, headers);

		if ((! sheet['id']) || (! sheet['extent'])){
			return;
		}

		var sw = {
			lat: parseFloat(sheet.extent[0]),
			lon: parseFloat(sheet.extent[1])
		};

		var ne = {
			lat: parseFloat(sheet.extent[2]),
			lon: parseFloat(sheet.extent[3])
		};

		sheets.push([sw, ne]);

		swlat = (swlat) ? Math.min(swlat, sw.lat) : sw.lat;
		swlon = (swlon) ? Math.min(swlon, sw.lon) : sw.lon;
		nelat = (nelat) ? Math.max(nelat, ne.lat) : ne.lat;
		nelon = (nelon) ? Math.max(nelon, ne.lon) : ne.lon;

		var nw = { 'lat': ne['lat'], 'lon': sw['lon'] };
		var se = { 'lat': sw['lat'], 'lon': ne['lon'] };

		var bbox = [[
			[sw['lon'], sw['lat']],
			[nw['lon'], nw['lat']],
			[ne['lon'], ne['lat']],
			[se['lon'], se['lat']],
			[sw['lon'], sw['lat']]
		]];

		return {
			geometry: {
				"type": "GeometryCollection",
				"geometries" : [
					{ type: "Polygon", coordinates: bbox, ima: 'sheet' },
				],
			},
			properties: sheet,
			bbox: [ sw, ne ],	// this is a hack
		};
	});

	var extent = [
		{ lat: swlat, lon: swlon },
		{ lat: nelat, lon: nelon },
	];

	return {
		'sheets': sheets,
		'bbox': extent,
		'features': features
	};
}

function draw_map_modestmaps(sheets){

	var bbox = utils_adjust_bbox(sheets['bbox']);

	var extent = [
		new com.modestmaps.Location(bbox[0]['lat'], bbox[0]['lon']),
		new com.modestmaps.Location(bbox[1]['lat'], bbox[1]['lon']),
	];

	var map = utils_modestmap('map');
	map.setExtent(extent);

	// see how this is different than what we pass
	// to polymaps? that's a known-known and today
	// it is a problem that is dressed in hairy yak
	// clothes...it should be sorted out though.
	// (20101028/straup)

	var polygons = [];

	count_sheets = sheets['sheets'].length;

	for (var i = 0; i < count_sheets; i++){

		var corners = sheets['sheets'][i];
		var sw = corners[0];
		var ne = corners[1];

		// this is seriously silly... we need to figure
		// out some common ground between modestmaps, polymaps,
		// modestmaps.markers and so on. for now this will
		// have to do... (20101029/straup)

		var nw = { 'lat': ne['lat'], 'lon': sw['lon'] };
		var se = { 'lat': sw['lat'], 'lon': ne['lon'] };

		var coords = [
			[sw['lat'], sw['lon']],
			[nw['lat'], nw['lon']],
			[ne['lat'], ne['lon']],
			[se['lat'], se['lon']],
			[sw['lat'], sw['lon']]
		];

		polygons.push(coords);
	}

	var attrs = {
		'fill' : '#00112d',
		'fill-opacity' : .5,
		'stroke' : '#99cc00',
		'stroke-width' : 4,
		'stroke-opacity' : 1,
	};

	var more = {
		'attrs' : attrs,
	};

	var markers = new com.modestmaps.Markers(map);
	markers.drawPolygons(polygons, more);

	utils_modestmaps_add_compass(map);
	return;
}

function draw_map_polymaps(sheets){

	var map = utils_polymap('map');

	var bbox = utils_adjust_bbox(sheets['bbox']);
	
	map.extent(bbox);
	map.zoom(Math.floor(map.zoom()));

	// tweak sheets['features'] here to add an abstract 
	// "sheet" thing-y at higher zoome levels positioned
	// at the center point of the sheet. at the moment we're
	// doing this in geojson when we could also just pass
	// some magic flag to have the SVG/etc. load an image
	// instead (20101203/straup)

	if ((_dotspotting.magicpony) && (map.zoom() <= 10)){

		var count = sheets['features'].length;

		for (var i=0; i < count; i++){

			var _geom = sheets['features'][i]['geometry'];
			var _bbox = sheets['features'][i]['bbox'];

			if ((! _bbox) || (! _geom['geometries'])){
				continue;
			}

			var sw = _bbox[0]; 
			var ne = _bbox[1];

			var _lat = sw['lat'] + ((ne['lat'] - sw['lat']) / 2);
			var _lon = sw['lon'] + ((ne['lon'] - sw['lon']) / 2);

			// this needs to reflect the map being zoomed in or out
			// rather than just being a fixed pair of values....

			var _x = parseInt((80 / map.zoom() / 2));
			var _y = parseInt((100 / map.zoom()) / 2);

			var _pt = map.locationPoint({ lat: _lat, lon: _lon });
			var _sw = map.pointLocation({ x: _pt.x - _x, y: _pt.y - _y });
			var _nw = map.pointLocation({ x: _pt.x - _x, y: _pt.y + _y });
			var _ne = map.pointLocation({ x: _pt.x + _x, y: _pt.y + _y });
			var _se = map.pointLocation({ x: _pt.x + _x, y: _pt.y - _y });

			var coords = [[
				[ _sw['lon'], _sw['lat'] ],
				[ _nw['lon'], _nw['lat'] ],
				[ _ne['lon'], _ne['lat'] ],
				[ _se['lon'], _se['lat'] ],
				[ _sw['lon'], _sw['lat'] ]
			]];

			_geom['geometries'].push({
				type : "Polygon",
				coordinates: coords,
				ima: 'magicpony',
			});
		}

	}

	// ok go!

	var boxes = org.polymaps.geoJson();
	boxes.features(sheets['features']);
	boxes.on("load", utils_polymaps_assign_sheet_properties);

	map.add(boxes);

	utils_polymaps_add_compass(map);
	return 1;
}

function draw_map(){

	utils_scrub_map();

	var sheets = collect_sheets();

	if (_dotspotting.use_polymaps){	
		draw_map_polymaps(sheets);
		return;
	}

	draw_map_modestmaps(sheets);
}
	
utils_load_map();

</script>
{/literal}
