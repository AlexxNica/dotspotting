{literal}
<script type="text/javascript">

function dot_onclick(e){
	// send click event and data to custom markerclick event
	// creates the tooltip

	jQuery("#map").trigger('markerclick',[e.data.props,e.data.geo]);
	
	/*
	if (dot['id']){
		location.href = dot.url;
	}
	*/
}


// helper function to highlight dot when user hovers over table row
function dot_tr_hover(el,type){
	var raw_dotid = (el.id).split("_");
	var dotid = raw_dotid[raw_dotid.length-1];
	if(type == "over"){
		dot_onmouseover(dotid);
	}else{
		dot_onmouseout(dotid);
		var tlen = _dotspotting.dots_list_mouseout_timers.length;

		for (var i = 0; i < tlen; i++){
			clearTimeout(_dotspotting.dots_list_mouseout_timers.pop());
		}
		dot_restore_tr();
	}
}


// returns string used in tooltip header text
function dot_tip_header(dotid){
	
	var dot = dot_getinfo(dotid);
	
	if (! dot['id']){
		return "";
	}

	var html = 'This is dot #<a href="' + dot.url + '">' + dot.id + '</a>';

	return html;

}

// returns string used in tooltip body text
function dot_tip_body(dotid){
	var dot = dot_getinfo(dotid);

	if (! dot['id']){
		return "";
	}

	var html = 'It is owned';

	if ((dot.ownerid) && (dot.ownerid != _dotspotting.user.id)){
		html += ' by ' + htmlspecialchars(dot.owner);
	}

	else {
		html += ' by you';
	}

	html += '.';

	if (dot.location){
		var search_url = _dotspotting.abs_root_url + 'search?l=' + encodeURIComponent(dot.location);
		html += ' It\'s located at <a href="' + search_url + '">' + htmlspecialchars(dot.location) + '</a>.';
	}

	else if (dot.latitude && dot.longitude){
		var search_url = _dotspotting.abs_root_url + 'search?gh=' + encodeGeoHash(dot.latitude, dot.longitude);
		html += ' It\'s located at <a href="' + search_url + '">' + dot.latitude + ',' + dot.longitude + '</a>.';
	}

	else {} 

	if (dot.type){
		var search_url = _dotspotting.abs_root_url + 'search?t=' + encodeURIComponent(dot.type);
		html += ' It\'s a <q><a href="' + search_url + '">' + htmlspecialchars(dot.type) + '</a></q>.';
	}
	
	html += ' <span class="date">Created on: ' + dot.created + '</span>';
	
	return html;
}

function resetBounds(){
	jQuery("#map").trigger('resetmapbounds');
}

function dot_onmouseover(dotid){

	var dot = dot_getinfo(dotid);

	if (! dot['id']){
		return;
	}

	var tlen = _dotspotting.dots_list_mouseout_timers.length;

	for (var i = 0; i < tlen; i++){
		clearTimeout(_dotspotting.dots_list_mouseout_timers.pop());
	}

	var html = 'This is dot #<a href="' + dot.url + '">' + dot.id + '</a>';

	if ((dot.ownerid) && (dot.ownerid != _dotspotting.user.id)){
		html += ', by ' + htmlspecialchars(dot.owner);
	}

	else {
		html += ', by you';
	}

	html += '.';

	if (dot.location){
		var search_url = _dotspotting.abs_root_url + 'search?l=' + encodeURIComponent(dot.location);
		html += ' It\'s located at <a href="' + search_url + '">' + htmlspecialchars(dot.location) + '</a>.';
	}

	else if (dot.latitude && dot.longitude){
		var search_url = _dotspotting.abs_root_url + 'search?gh=' + encodeGeoHash(dot.latitude, dot.longitude);
		html += ' It\'s located at <a href="' + search_url + '">' + dot.latitude + ',' + dot.longitude + '</a>.';
	}

	else {} 

	if (dot.type){
		var search_url = _dotspotting.abs_root_url + 'search?t=' + encodeURIComponent(dot.type);
		html += ' It\'s a <q><a href="' + search_url + '">' + htmlspecialchars(dot.type) + '</a></q>.';
	}
	
	/*
		$("#map_info").html(html);
		$("#map_info").show();
	*/
	
	/* Move dot to bottom of group */
	var element = document.getElementById("dot_"+dotid);
	element.parentNode.appendChild(element);
	
	/* Add dot hover class, because appendChild breaks ':hover' */
	var classes = (element.className.baseVal).split(' ');
	classes.push('dotHover');
	element.setAttribute('class', classes.join(' '));	
	
	dot_highlight_tr(dotid);
}

function dot_onmouseout(dotid){
	
	/* Remove dot hover class */
	var element = document.getElementById("dot_"+dotid);
	var classes = (element.className.baseVal).split(' ');
	classes.pop();
	element.setAttribute('class', classes.join(' '));

	/*
	var html = $("#map_info").html();
	html = html.replace(/^This is/, 'That was');

	$("#map_info").html(html);
	*/
	
	var tid = setTimeout(function(){

		$("#map_info").fadeOut('slow', function(){
			$("#map_info").html('');
		});

		dot_restore_tr();

	}, 8000);

	_dotspotting.dots_list_mouseout_timers.push(tid);
}

function dot_highlight_tr(dotid){

	dot_restore_tr();

	var selector = "#dotslist_dot_" + dotid + " td";

	_dotspotting['highlighted'] = dotid;

	$(selector).map(function(i, el) {
		var new_classes = el.getAttribute("class") + " highlighted";
		el.setAttribute("class", new_classes);	
	});
}

function dot_restore_tr(){

	var current = _dotspotting['highlighted'];

	if (! current){
		return;
	}

	var selector = "#dotslist_dot_" + current + " td";

	$(selector).map(function(i, el){
		var new_classes = el.getAttribute("class").replace(" highlighted", "");
		el.setAttribute("class", new_classes);
	});

	_dotspotting['highlighted'] = null;
}

function dot_getinfo(dotid){

    if (_dotspotting.dots_list_dots[dotid]){	
       return _dotspotting.dots_list_dots[dotid];
    }      
    	 
    var row = $("#dotslist_dot_" + dotid);
    var dot = row2dot(row);

    _dotspotting.dots_list_dots[dotid] = dot;
    return dot;
}

function row2dot(row, headers){

	var dot = {};

	$(row).find("td").each(function(col, td){

		var classes = $(td).attr("class");
		var key = (headers) ? headers[col] : null;

		if (classes){

			var match = classes.match(/\bdotslist_([a-z_]+)\b/);

			if (match){
				key = match[1];
			}
		}

		if (! key){
			return {};
		}

		var value = $(td).text()
		value = value.replace(/^\s+/, '');
		value = value.replace(/\s+$/, '');

		if (key == 'dotid'){
			value = Number(value);
		}

		else if (key.match(/(?:latitude|longitude)/)){
			value = parseFloat(value);
		}

		else if (key.match(/(?:details|other)/)){
			value = value.split(',');
		}

		else if (key.match(/(?:location|type)/)){
			value = (value == 'â€”') ? null : value;
		}

		else if (key == 'owner'){

			// I am not convinced this is the right way to do this...

			var ownerid = $(td).attr("ds:owner_id");

			if (ownerid){
				dot['ownerid'] = Number(ownerid);
			}
		}

		// parse 'created' date here?

		else {}

		dot[key] = value;
	});

	dot['url'] = _dotspotting.abs_root_url + 'u/' + dot['ownerid'] + '/dots/' + dot.id + '/';
	return dot;
}

function collect_headers(){

	var headers = $("#user_dots thead tr").map(function(i, row){

		var _headers = [];

		$(row).find("th").each(function(col, th){
			_headers.push($(th).text().toLowerCase());
		});

		return _headers;
	});

	return headers;
}

function collect_dots(){

	var headers = collect_headers();

	var swlat = null;
	var swlon = null;
	var nelat = null;
	var nelon = null;

	var features = $("#user_dots tbody tr").map(function(i, row){

		var dot = row2dot(row);

		var loc = {
			lat: dot.latitude,
			lon: dot.longitude,
		};

		swlat = (swlat) ? Math.min(swlat, loc.lat) : loc.lat;
		swlon = (swlon) ? Math.min(swlon, loc.lon) : loc.lon;
		nelat = (nelat) ? Math.max(nelat, loc.lat) : loc.lat;
		nelon = (nelon) ? Math.max(nelon, loc.lon) : loc.lon;

		dot.is_interactive = true;

		return {
			'geometry' : {
				'type' : 'Point',
				'coordinates' : [ loc.lon, loc.lat ],
			},

			'properties' : dot,
		};

	});

	var extent = [
		{ lat: swlat, lon: swlon },
		{ lat: nelat, lon: nelon },
	];

	var center = {
		'lat' : swlat + ((nelat - swlat) / 2),
		'lon' : swlon + ((nelon - swlon) / 2),
	};

	return {
		'features': features,
		'extent' : extent,
		'center' : center,
	};
}

function draw_map_modestmaps(dots){

	var mm = com.modestmaps;
	var map = utils_modestmap('map');

	if (dots.features.length == 1){

		var center = dots['center'];
		var zoom = 14;

		var loc = new mm.Location(center['lat'], center['lon']);
    		map.setCenterZoom(loc, zoom);

	}

	else {
		var _extent = utils_adjust_bbox(dots['extent']);

		var extent = [
			new mm.Location(_extent[0]['lat'], _extent[0]['lon']),
			new mm.Location(_extent[1]['lat'], _extent[1]['lon']),
		];

		map.setExtent(extent);
	}

	// This is not awesome but in the absence of a reliable way to
	// read CSS declaration in JS (does one exist now?) it's just
	// what we're going to do for now. See also: main.css .dot and
	// .dot:hover (20101207/straup)

	var attrs = {
		'fill' : '#00112d',
		'fill-opacity' : .5,
		'stroke' : '#99cc00',
		'stroke-width' : 3,
		'stroke-opacity' : 1,
	};

	var attrs_hover = {
		'fill' : '#00ddee',
		'fill-opacity' : .8,
		'stroke' : '#00112d',
		'stroke-width' : 5,
		'stroke-opacity' : 1,
	};

	var more = {
		'attrs' : attrs,

		// just inline the function mostly so that we don't
		// have to redeclare the attrs_* hashes again
		// (20101207/straup)

		'onload' : function(el, props){

			el.mouseout(function (evt) {
				this.attr(attrs);
				dot_onmouseout(props.id);
			});

			el.mouseover(function (evt) {
				this.attr(attrs_hover);
				dot_onmouseover(props.id);
			});

			el.click(function(evt){
				dot_onclick(props.id);
			});
		},
	};

	var markers = new mm.Markers(map);
	markers.drawGeoJson(dots['features'], more);

	utils_modestmaps_add_compass(map);	
	return;
}

function draw_map_polymaps(dots){

	var map = utils_polymap('map');

	if (dots.features.length == 1){
		map.center(dots.center);
	}

	else {
		var extent = utils_adjust_bbox(dots.extent);
		map.extent(extent);
	}

	map.zoom(Math.floor(map.zoom()));

	var po = org.polymaps;
	var points = po.geoJson();
	points.features(dots['features']);
	points.on("load", utils_polymaps_assign_dot_properties);

	map.add(points);

	utils_polymaps_add_compass(map);
	
	$("#map").bind('resetmapbounds', function(e) {
		var extent = utils_adjust_bbox(dots.extent);
		map.extent(extent);
	});
	
	/* 
		Add ToolTip & bind marker click event to #map
		
		tooltip appears on click
		
		#############################################################################
		Because they look so good,
		code & styles from Portland crime map: https://github.com/Caged/portlandcrime
		#############################################################################
	*/

	var mapel = $("#map").parent();
	
	$("#map").bind('markerclick', function(e,props,geo) {
		if(mapel.length == 0) return
		
		var dotid = props.id;
		var coor = geo.coordinates;
		
		mapel.maptip(this)
	      .map(map)
	      .data(props)
	      .location({lat: coor[1], lon: coor[0]})
	      .classNames(function(d) {
	        return d.code
	      })
	      .top(function(tip) {
	        var point = tip.props.map.locationPoint(this.props.location)
	        return parseFloat(point.y)
	      }).left(function(tip) {
	        var radius = tip.target.getAttribute('r'),
	            point = tip.props.map.locationPoint(this.props.location)

	        return parseFloat(point.x + (radius / 2.0) + 20)
	      }).content(function(d) {
	        var self = this,
	            props = d,
	            cnt = $('<div/>'),
	            hdr = $('<h2/>'),
	            bdy = $('<p/>'),

	            close = $('<span/>').addClass('close').text('X')

	        hdr.html(dot_tip_header(props.id));
	         hdr.append(close)
	        

	        bdy.html(dot_tip_body(props.id))

	        cnt.append($('<div/>').addClass('nub'))
	        cnt.append(hdr).append(bdy) 

	        close.click(function() {
	          self.hide()
	        })   

	        return cnt  
	      }).render()

	});

	return 1;
}
	
function draw_map(){

	utils_scrub_map();

	var dots = collect_dots();

	if (_dotspotting.use_polymaps){	
		draw_map_polymaps(dots);
		return;
	}

	draw_map_modestmaps(dots);
}
	
utils_load_map();
  
</script>
{/literal}
