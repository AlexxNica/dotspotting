{literal}
<script type="text/javascript">

function dot_onclick(dotid){

	var dot = dot_getinfo(dotid);

	if (dot['id']){
		location.href = dot.url;
	}
}

function dot_onmouseover(dotid){

	var dot = dot_getinfo(dotid);

	if (! dot['id']){
		return;
	}

	var tlen = _dotspotting.dots_list_mouseout_timers.length;

	for (var i = 0; i < tlen; i++){
		clearTimeout(_dotspotting.dots_list_mouseout_timers.pop());
	}

	var html = 'This is dot #<a href="' + dot.url + '">' + dot.id + '</a>';

	if ((dot.ownerid) && (dot.ownerid != _dotspotting.user.id)){
		html += ', by ' + htmlspecialchars(dot.owner);
	}

	else {
		html += ', by you';
	}

	html += '.';

	if (dot.location){
		var search_url = _dotspotting.abs_root_url + 'search?l=' + encodeURIComponent(dot.location);
		html += ' It\'s located at <a href="' + search_url + '">' + htmlspecialchars(dot.location) + '</a>.';
	}

	else if (dot.latitude && dot.longitude){
		var search_url = _dotspotting.abs_root_url + 'search?gh=' + encodeGeoHash(dot.latitude, dot.longitude);
		html += ' It\'s located at <a href="' + search_url + '">' + dot.latitude + ',' + dot.longitude + '</a>.';
	}

	else {} 

	if (dot.type){
		var search_url = _dotspotting.abs_root_url + 'search?t=' + encodeURIComponent(dot.type);
		html += ' It\'s a <q><a href="' + search_url + '">' + htmlspecialchars(dot.type) + '</a></q>.';
	}

	$("#map_info").html(html);
	$("#map_info").show();
}

function dot_onmouseout(dotid){

	var html = $("#map_info").html();
	html = html.replace(/^This is/, 'That was');

	$("#map_info").html(html);

	var tid = setTimeout(function(){

		$("#map_info").fadeOut('slow', function(){
			$("#map_info").html('');
		});

	}, 8000);

	_dotspotting.dots_list_mouseout_timers.push(tid);
}

function dot_getinfo(dotid){

    if (_dotspotting.dots_list_dots[dotid]){	
       return _dotspotting.dots_list_dots[dotid];
    }      
    	 
    var row = $("#dotslist_dot_" + dotid);
    var dot = row2dot(row);

    _dotspotting.dots_list_dots[dotid] = dot;
    return dot;
}

function row2dot(row, headers){

	var dot = {};

	$(row).find("td").each(function(col, td){

		var classes = $(td).attr("class");
		var key = (headers) ? headers[col] : null;

		if (classes){

			var match = classes.match(/\bdotslist_([a-z_]+)\b/);

			if (match){
				key = match[1];
			}
		}

		if (! key){
			return {};
		}

		var value = $(td).text()
		value = value.replace(/^\s+/, '');
		value = value.replace(/\s+$/, '');

		if (key == 'dotid'){
			value = Number(value);
		}

		else if (key.match(/(?:latitude|longitude)/)){
			value = parseFloat(value);
		}

		else if (key.match(/(?:details|other)/)){
			value = value.split(',');
		}

		else if (key.match(/(?:location|type)/)){
			value = (value == 'â€”') ? null : value;
		}

		else if (key == 'owner'){

			// I am not convinced this is the right way to do this...

			var ownerid = $(td).attr("ds:owner_id");

			if (ownerid){
				dot['ownerid'] = Number(ownerid);
			}
		}

		// parse 'created' date here?

		else {}

		dot[key] = value;
	});

	dot['url'] = _dotspotting.abs_root_url + 'u/' + dot['ownerid'] + '/dots/' + dot.id + '/';
	return dot;
}

function collect_headers(){

	var headers = $("#user_dots thead tr").map(function(i, row){

		var _headers = [];

		$(row).find("th").each(function(col, th){
			_headers.push($(th).text().toLowerCase());
		});

		return _headers;
	});

	return headers;
}

function collect_dots(){

	var locations = [];

	var headers = collect_headers();

	var features = $("#user_dots tbody tr").map(function(i, row){

		var dot = row2dot(row);

		var loc = {
			lat: dot.latitude,
			lon: dot.longitude,
		};

		if (! isNaN(loc.lat) && ! isNaN(loc.lon)){
			locations.push(loc);
		}

		return {
			geometry: {
				type: "Point",
				coordinates: [loc.lon, loc.lat]
			},

			properties: dot
		};
	});

	return { 'locations': locations, 'features': features };
}

function calculate_extents(dots){

	if (dots['locations'].length == 0){

		return {
			'bbox': [ { 'lat': -85, 'lon': -180 },	{ 'lat': 85, 'lon': 180 } ],
			'center': { 'lat': 37.764862, 'lon': -122.419431 },
		}
	}

	// figure out the extent and center point

	var center = {lat: 0, lon: 0};

	var swlat = null;
	var swlon = null;
	var nelat = null;
	var nelon = null;

	for (var i = 0; i < dots['locations'].length; i++){
		var loc = dots['locations'][i];
		center.lat += loc.lat;
		center.lon += loc.lon;

		swlat = (swlat) ? Math.min(swlat, loc.lat) : loc.lat;
		swlon = (swlon) ? Math.min(swlon, loc.lon) : loc.lon;
		nelat = (nelat) ? Math.max(nelat, loc.lat) : loc.lat;
		nelon = (nelon) ? Math.max(nelon, loc.lon) : loc.lon;
	}

	var bbox = [
		{ lat: swlat, lon: swlon },
		{ lat: nelat, lon: nelon },
	];

	center.lat /= dots['locations'].length;
	center.lon /= dots['locations'].length;

	return { 'bbox': bbox, 'center': center };
}

function draw_map_modestmaps(dots){

	var extents = calculate_extents(dots);

	if (! extents){
		return;
	}

	var count = dots['locations'].length;

	var mm = com.modestmaps;
	var map = utils_modestmap('map');

	if (count == 1){

		var center = extents['center'];
		var zoom = 14;

		var loc = new mm.Location(center['lat'], center['lon']);
    		map.setCenterZoom(loc, zoom);

	}

	else {
		var bbox = utils_adjust_bbox(extents['bbox']);

		var extent = [
			new mm.Location(bbox[0]['lat'], bbox[0]['lon']),
			new mm.Location(bbox[1]['lat'], bbox[1]['lon']),
		];

		map.setExtent(extent);
	}

	// see how this is different than what we pass
	// to polymaps? that's a known-known and today
	// it is a problem that is dressed in hairy yak
	// clothes...it should be sorted out though.
	// (20101028/straup)

	var points = []

	for (var i = 0; i < count; i++){
		var loc = dots['locations'][i];
		points.push([ loc.lat, loc.lon ]);
	}

	var more = {
		'r': 8
	};

	var markers = new mm.Markers(map);
	markers.drawPoints(points, more);

	utils_modestmaps_add_compass(map);	
	return;
}

function draw_map_polymaps(dots){

	var extents = calculate_extents(dots);

	if (! extents){
		return;
	}

	var map = utils_polymap('map');

	if (dots['locations'].length == 1){
		map.center(extents['center']);
	}

	else {
		var bbox = utils_adjust_bbox(extents['bbox']);
		map.extent(bbox);
	}

	map.zoom(Math.floor(map.zoom()));

	var po = org.polymaps;
	var points = po.geoJson();
	points.features(dots['features']);
	points.on("load", utils_polymaps_assign_dot_properties);

	map.add(points);

	utils_polymaps_add_compass(map);
	return 1;
}
	
function draw_map(){

	utils_scrub_map();

	var dots = collect_dots();

	if (_dotspotting.use_polymaps){	
		draw_map_polymaps(dots);
		return;
	}

	draw_map_modestmaps(dots);
}
	
utils_load_map();
  
</script>
{/literal}
