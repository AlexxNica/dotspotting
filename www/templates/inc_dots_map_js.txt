{literal}
<script type="text/javascript">

function dot_onclick(dotid){

	var dot = dot_getinfo(dotid);

	if (dot['id']){
		location.href = dot.url;
	}
}

function dot_onmouseover(dotid){

	var dot = dot_getinfo(dotid);

	if (! dot['id']){
		return;
	}

	var tlen = _dotspotting.dots_list_mouseout_timers.length;

	for (var i = 0; i < tlen; i++){
		clearTimeout(_dotspotting.dots_list_mouseout_timers.pop());
	}

	var html = 'This is dot #<a href="' + dot.url + '">' + dot.id + '</a>';

	if ((dot.ownerid) && (dot.ownerid != _dotspotting.user.id)){
		html += ', by ' + htmlspecialchars(dot.owner);
	}

	else {
		html += ', by you';
	}

	html += '.';

	if (dot.location){
		var search_url = _dotspotting.abs_root_url + 'search?l=' + encodeURIComponent(dot.location);
		html += ' It\'s located at <a href="' + search_url + '">' + htmlspecialchars(dot.location) + '</a>.';
	}

	else if (dot.latitude && dot.longitude){
		var search_url = _dotspotting.abs_root_url + 'search?gh=' + encodeGeoHash(dot.latitude, dot.longitude);
		html += ' It\'s located at <a href="' + search_url + '">' + dot.latitude + ',' + dot.longitude + '</a>.';
	}

	else {} 

	if (dot.type){
		var search_url = _dotspotting.abs_root_url + 'search?t=' + encodeURIComponent(dot.type);
		html += ' It\'s a <q><a href="' + search_url + '">' + htmlspecialchars(dot.type) + '</a></q>.';
	}

	$("#map_info").html(html);
	$("#map_info").show();
}

function dot_onmouseout(dotid){

	var html = $("#map_info").html();
	html = html.replace(/^This is/, 'That was');

	$("#map_info").html(html);

	var tid = setTimeout(function(){

		$("#map_info").fadeOut('slow', function(){
			$("#map_info").html('');
		});

	}, 8000);

	_dotspotting.dots_list_mouseout_timers.push(tid);
}

function dot_getinfo(dotid){

    if (_dotspotting.dots_list_dots[dotid]){	
       return _dotspotting.dots_list_dots[dotid];
    }      
    	 
    var row = $("#dotslist_dot_" + dotid);
    var dot = row2dot(row);

    _dotspotting.dots_list_dots[dotid] = dot;
    return dot;
}

function row2dot(row, headers){

	var dot = {};

	$(row).find("td").each(function(col, td){

		var classes = $(td).attr("class");
		var key = (headers) ? headers[col] : null;

		if (classes){

			var match = classes.match(/\bdotslist_([a-z_]+)\b/);

			if (match){
				key = match[1];
			}
		}

		if (! key){
			return {};
		}

		var value = $(td).text()
		value = value.replace(/^\s+/, '');
		value = value.replace(/\s+$/, '');

		if (key == 'dotid'){
			value = Number(value);
		}

		else if (key.match(/(?:latitude|longitude)/)){
			value = parseFloat(value);
		}

		else if (key.match(/(?:details|other)/)){
			value = value.split(',');
		}

		else if (key.match(/(?:location|type)/)){
			value = (value == 'â€”') ? null : value;
		}

		else if (key == 'owner'){

			// I am not convinced this is the right way to do this...

			var ownerid = $(td).attr("ds:owner_id");

			if (ownerid){
				dot['ownerid'] = Number(ownerid);
			}
		}

		// parse 'created' date here?

		else {}

		dot[key] = value;
	});

	dot['url'] = _dotspotting.abs_root_url + 'u/' + dot['ownerid'] + '/dots/' + dot.id + '/';
	return dot;
}

function collect_headers(){

	var headers = $("#user_dots thead tr").map(function(i, row){

		var _headers = [];

		$(row).find("th").each(function(col, th){
			_headers.push($(th).text().toLowerCase());
		});

		return _headers;
	});

	return headers;
}

function collect_dots(){

	var headers = collect_headers();

	var swlat = null;
	var swlon = null;
	var nelat = null;
	var nelon = null;

	var features = $("#user_dots tbody tr").map(function(i, row){

		var dot = row2dot(row);

		var loc = {
			lat: dot.latitude,
			lon: dot.longitude,
		};

		swlat = (swlat) ? Math.min(swlat, loc.lat) : loc.lat;
		swlon = (swlon) ? Math.min(swlon, loc.lon) : loc.lon;
		nelat = (nelat) ? Math.max(nelat, loc.lat) : loc.lat;
		nelon = (nelon) ? Math.max(nelon, loc.lon) : loc.lon;

		dot.is_interactive = true;

		return {
			'geometry' : {
				'type' : 'Point',
				'coordinates' : [ loc.lon, loc.lat ],
			},

			'properties' : dot,
		};

	});

	var extent = [
		{ lat: swlat, lon: swlon },
		{ lat: nelat, lon: nelon },
	];

	var center = {
		'lat' : swlat + ((nelat - swlat) / 2),
		'lon' : swlon + ((nelon - swlon) / 2),
	};

	return {
		'features': features,
		'extent' : extent,
		'center' : center,
	};
}

function draw_map_modestmaps(dots){

	var mm = com.modestmaps;
	var map = utils_modestmap('map');

	if (dots.features.length == 1){

		var center = dots['center'];
		var zoom = 14;

		var loc = new mm.Location(center['lat'], center['lon']);
    		map.setCenterZoom(loc, zoom);

	}

	else {
		var _extent = utils_adjust_bbox(dots['extent']);

		var extent = [
			new mm.Location(_extent[0]['lat'], _extent[0]['lon']),
			new mm.Location(_extent[1]['lat'], _extent[1]['lon']),
		];

		map.setExtent(extent);
	}

	// This is not awesome but in the absence of a reliable way to
	// read CSS declaration in JS (does one exist now?) it's just
	// what we're going to do for now. See also: main.css .dot and
	// .dot:hover (20101207/straup)

	var attrs = {
		'fill' : '#00112d',
		'fill-opacity' : .5,
		'stroke' : '#99cc00',
		'stroke-width' : 3,
		'stroke-opacity' : 1,
	};

	var attrs_hover = {
		'fill' : '#00ddee',
		'fill-opacity' : .8,
		'stroke' : '#00112d',
		'stroke-width' : 5,
		'stroke-opacity' : 1,
	};

	var more = {
		'attrs' : attrs,

		// just inline the function mostly so that we don't
		// have to redeclare the attrs_* hashes again
		// (20101207/straup)

		'onload' : function(el, props){

			el.mouseout(function (evt) {
				this.attr(attrs);
				dot_onmouseout(props.id);
			});

			el.mouseover(function (evt) {
				this.attr(attrs_hover);
				dot_onmouseover(props.id);
			});

			el.click(function(evt){
				dot_onclick(props.id);
			});
		},
	};

	var markers = new mm.Markers(map);
	markers.drawGeoJson(dots['features'], more);

	utils_modestmaps_add_compass(map);	
	return;
}

function draw_map_polymaps(dots){

	var map = utils_polymap('map');

	if (dots.features.length == 1){
		map.center(dots.center);
	}

	else {
		var extent = utils_adjust_bbox(dots.extent);
		map.extent(extent);
	}

	map.zoom(Math.floor(map.zoom()));

	var po = org.polymaps;
	var points = po.geoJson();
	points.features(dots['features']);
	points.on("load", utils_polymaps_assign_dot_properties);

	map.add(points);

	utils_polymaps_add_compass(map);
	return 1;
}
	
function draw_map(){

	utils_scrub_map();

	var dots = collect_dots();

	if (_dotspotting.use_polymaps){	
		draw_map_polymaps(dots);
		return;
	}

	draw_map_modestmaps(dots);
}
	
utils_load_map();
  
</script>
{/literal}
