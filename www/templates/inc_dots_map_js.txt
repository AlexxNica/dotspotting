{literal}
<script type="text/javascript">

function collect_dots(){

	// read the table looking for dots

	var selector = "#user_dots tbody tr";
	var locations = [];

	var features = $(selector).map(function(i, row) {
		var values = {};

		// this is pretty brittle and should be updated
		// to check for class names instead of offsets
		// (20101027/straup)

		$(row).find("td").each(function(col, td) {
			values[col] = $(td).text();
		});

		var loc = {
			lat: parseFloat(values[3]),
			lon: parseFloat(values[4])
		};

		if (!isNaN(loc.lat) && !isNaN(loc.lon)) {
			locations.push(loc);
		}

		return {
			geometry: {
				type: "Point",
				coordinates: [loc.lon, loc.lat]
			},
			properties: {
				id: values[0],
				permissions: values[8]
			}
		};
	});

	return { 'locations': locations, 'features': features };
}

function calculate_extents(dots){

	if (dots['locations'].length == 0){

		return {
			'bbox': [ { 'lat': -85, 'lon': -180 },	{ 'lat': 85, 'lon': 180 } ],
			'center': { 'lat': 37.764862, 'lon': -122.419431 },
		}
	}

	// figure out the extent and center point

	var center = {lat: 0, lon: 0};

	var swlat = null;
	var swlon = null;
	var nelat = null;
	var nelon = null;

	for (var i = 0; i < dots['locations'].length; i++){
		var loc = dots['locations'][i];
		center.lat += loc.lat;
		center.lon += loc.lon;

		swlat = (swlat) ? Math.min(swlat, loc.lat) : loc.lat;
		swlon = (swlon) ? Math.min(swlon, loc.lon) : loc.lon;
		nelat = (nelat) ? Math.max(nelat, loc.lat) : loc.lat;
		nelon = (nelon) ? Math.max(nelon, loc.lon) : loc.lon;
	}

	var bbox = [
		{ lat: swlat, lon: swlon },
		{ lat: nelat, lon: nelon },
	];

	center.lat /= dots['locations'].length;
	center.lon /= dots['locations'].length;

	return { 'bbox': bbox, 'center': center };
}

function draw_map_modestmaps(dots){

	var extents = calculate_extents(dots);

	if (! extents){
		return;
	}

	var count = dots['locations'].length;

	var mm = com.modestmaps;
	var map = utils_modestmap('map');

	if (count == 1){

		var center = extents['center'];
		var zoom = 14;

		var loc = new mm.Location(center['lat'], center['lon']);
    		map.setCenterZoom(loc, zoom);

	}

	else {
		var bbox = utils_adjust_bbox(extents['bbox']);

		var extent = [
			new mm.Location(bbox[0]['lat'], bbox[0]['lon']),
			new mm.Location(bbox[1]['lat'], bbox[1]['lon']),
		];

		map.setExtent(extent);
	}

	// see how this is different than what we pass
	// to polymaps? that's a known-known and today
	// it is a problem that is dressed in hairy yak
	// clothes...it should be sorted out though.
	// (20101028/straup)

	var points = []

	for (var i = 0; i < count; i++){
		var loc = dots['locations'][i];
		points.push([ loc.lat, loc.lon ]);
	}

	var more = { 'globalAlpha' : 1, 'r': 8 };

	var markers = new mm.Markers(map);
	markers.drawPoints(points, more);

	utils_modestmaps_add_compass(map);	
	return;
}

function draw_map_polymaps(dots){

	var extents = calculate_extents(dots);

	if (! extents){
		return;
	}

	var map = utils_polymap('map');

	if (dots['locations'].length == 1){
		map.center(extents['center']);
	}

	else {
		var bbox = utils_adjust_bbox(extents['bbox']);
		map.extent(bbox);
	}

	map.zoom(Math.floor(map.zoom()));

	var po = org.polymaps;
	var points = po.geoJson();
	points.features(dots['features']);
	points.on("load", utils_polymaps_assign_dot_properties);

	map.add(points);

	utils_polymaps_add_compass(map);
	return 1;
}
	
function draw_map(){

	// just blow away the map (if a datatable is filtered)

	var mom = $("#map");
	var kids = mom.children();

	if (kids.length){
		kids.remove();
	}

	var dots = collect_dots();

	if (canhas_polymaps){	
		draw_map_polymaps(dots);
		return;
	}

	draw_map_modestmaps(dots);
}
	
draw_map();
  
</script>
{/literal}
